<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>理解堆和栈 | 吃饭的博客</title><meta name="author" content="吃饭"><meta name="copyright" content="吃饭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="堆和栈">
<meta property="og:type" content="article">
<meta property="og:title" content="理解堆和栈">
<meta property="og:url" content="http://example.com/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/index.html">
<meta property="og:site_name" content="吃饭的博客">
<meta property="og:description" content="堆和栈">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/%E9%97%B4%E8%B0%8D%E8%BF%87%E5%AE%B6%E5%AE%B6.jpg">
<meta property="article:published_time" content="2022-06-01T08:35:05.000Z">
<meta property="article:modified_time" content="2022-06-01T08:20:35.384Z">
<meta property="article:author" content="吃饭">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E9%97%B4%E8%B0%8D%E8%BF%87%E5%AE%B6%E5%AE%B6.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 吃饭","link":"链接: ","source":"来源: 吃饭的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '理解堆和栈',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-01 16:20:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/%E9%97%B4%E8%B0%8D%E8%BF%87%E5%AE%B6%E5%AE%B6.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">吃饭的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">理解堆和栈</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-01T08:35:05.000Z" title="发表于 2022-06-01 16:35:05">2022-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-01T08:20:35.384Z" title="更新于 2022-06-01 16:20:35">2022-06-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="理解堆和栈"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>@[toc]</p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><h3 id="一、预备知识—程序的内存分配"><a href="#一、预备知识—程序的内存分配" class="headerlink" title="一、预备知识—程序的内存分配"></a>一、预备知识—程序的内存分配</h3><p>一个由c/C++编译的程序占用的内存分为以下几个部分<br>1、栈区（stack）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br>2、堆区（heap）：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>3、全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放<br>4、文字常量区：常量字符串就是放在这里的。 程序结束后由系统释放<br>5、程序代码区：存放函数体的二进制代码。 </p>
<p>二、例子程序<br>这是一个前辈写的，非常详细<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp  </span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>; 全局初始化区  </span><br><span class="line"><span class="type">char</span> *p1; 全局未初始化区  </span><br><span class="line">main()  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> b; 栈  </span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; 栈  </span><br><span class="line">	<span class="type">char</span> *p2; 栈  </span><br><span class="line">	<span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="number">123456</span>\<span class="number">0</span>在常量区，p3在栈上。  </span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> c =<span class="number">0</span>； 全局（静态）初始化区  </span><br><span class="line">	p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);  </span><br><span class="line">	p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);  </span><br><span class="line">	分配得来得<span class="number">10</span>和<span class="number">20</span>字节的区域就在堆区。  </span><br><span class="line">	<span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>); <span class="number">123456</span>\<span class="number">0</span>放在常量区，编译器可能会将它与p3所指向的<span class="string">&quot;123456&quot;</span>优化成一个地方。  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<h3 id="二、堆和栈的理论知识"><a href="#二、堆和栈的理论知识" class="headerlink" title="二、堆和栈的理论知识"></a>二、堆和栈的理论知识</h3><p><strong>2.1申请方式</strong><br>stack:<br>由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间<br>heap:<br>需要程序员自己申请，并指明大小，在c中malloc函数<br>如p1 = (char <em>)malloc(10);<br>在C++中用new运算符<br>如p2 = (char </em>)malloc(10);<br>但是注意p1、p2本身是在栈中的。  </p>
<p><strong>2.2  申请后系统的响应</strong><br>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。  </p>
<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，  会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。  </p>
<p><strong>2.3申请大小的限制</strong><br>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。  </p>
<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。  </p>
<p><strong>2.4申请效率的比较：</strong><br>栈由系统自动分配，速度较快。但程序员是无法控制的。  </p>
<p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.  另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。  </p>
<p><strong>2.5堆和栈中的存储内容</strong><br>栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。  </p>
<p>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。  </p>
<p><strong>2.6存取效率的比较</strong><br>char s1[] = “aaaaaaaaaaaaaaa”;<br>char <em>s2 = “bbbbbbbbbbbbbbbbb”;<br>aaaaaaaaaaa是在运行时刻赋值的；<br>而bbbbbbbbbbb是在编译时就确定的；<br>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。<br>比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">char</span> a = <span class="number">1</span>;  </span><br><span class="line">	<span class="type">char</span> c[] = <span class="string">&quot;1234567890&quot;</span>;  </span><br><span class="line">	<span class="type">char</span> *p =<span class="string">&quot;1234567890&quot;</span>;  </span><br><span class="line">	a = c[<span class="number">1</span>];  </span><br><span class="line">	a = p[<span class="number">1</span>];  </span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><br><em>*对应的汇编代码</em></em><br>10: a = c[1];<br>00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]<br>0040106A 88 4D FC mov byte ptr [ebp-4],cl<br>11: a = p[1];<br>0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]<br>00401070 8A 42 01 mov al,byte ptr [edx+1]<br>00401073 88 45 FC mov byte ptr [ebp-4],al<br>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。  </p>
<p><strong>2.7小结：</strong><br>堆和栈的区别可以用如下的比喻来看出：<br>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。  </p>
<p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。  </p>
<h3 id="windows进程中的内存结构"><a href="#windows进程中的内存结构" class="headerlink" title="windows进程中的内存结构"></a>windows进程中的内存结构</h3><p>在阅读本文之前，如果你连堆栈是什么多不知道的话，请先阅读文章后面的基础知识。  </p>
<p>接触过编程的人都知道，高级语言都能通过变量名来访问内存中的数据。那么这些变量在内存中是如何存放的呢？程序又是如何使用这些变量的呢？下面就会对此进行深入的讨论。下文中的C语言代码如没有特别声明，默认都使用VC编译的release版。  </p>
<p>首先，来了解一下 C 语言的变量是如何在内存分部的。C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g1=<span class="number">0</span>, g2=<span class="number">0</span>, g3=<span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s1=<span class="number">0</span>, s2=<span class="number">0</span>, s3=<span class="number">0</span>;  </span><br><span class="line">	<span class="type">int</span> v1=<span class="number">0</span>, v2=<span class="number">0</span>, v3=<span class="number">0</span>;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">//打印出各个变量的内存地址  </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;v1); <span class="comment">//打印各本地变量的内存地址  </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;v2);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n\n&quot;</span>,&amp;v3);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;g1); <span class="comment">//打印各全局变量的内存地址  </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;g2);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n\n&quot;</span>,&amp;g3);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;s1); <span class="comment">//打印各静态变量的内存地址  </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;s2);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n\n&quot;</span>,&amp;s3);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>编译后的执行结果是：  </p>
<p>0x0012ff78<br>0x0012ff7c<br>0x0012ff80  </p>
<p>0x004068d0<br>0x004068d4<br>0x004068d8  </p>
<p>0x004068dc<br>0x004068e0<br>0x004068e4  </p>
<p>输出的结果就是变量的内存地址。其中v1,v2,v3是本地变量，g1,g2,g3是全局变量，s1,s2,s3是静态变量。你可以看到这些变量在内存是连续分布的，<strong>但是本地变量和全局变量分配的内存地址差了十万八千里，而全局变量和静态变量分配的内存是连续的。这是因为本地变量和全局/静态变量是分配在不同类型的内存区域中的结果</strong>。对于一个进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。<strong>动态数据区一般就是“堆栈”。“栈(stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”</strong>，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。<strong>全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。</strong>  </p>
<p>├———————┤低端内存区域<br>│ …… │<br>├———————┤<br>│ 动态数据区 │<br>├———————┤<br>│ …… │<br>├———————┤<br>│ 代码区 │<br>├———————┤<br>│ 静态数据区 │<br>├———————┤<br>│ …… │<br>├———————┤高端内存区域  </p>
<p>堆栈是一个先进后出的数据结构，栈顶地址总是小于等于栈的基地址。我们可以先了解一下函数调用的过程，以便对堆栈在程序中的作用有更深入的了解。不同的语言有不同的函数调用规定，这些因素有参数的压入规则和堆栈的平衡。windows API的调用规则和ANSI C的函数调用规则是不一样的，前者由被调函数调整堆栈，后者由调用者调整堆栈。两者通过“<strong>stdcall”和“</strong>cdecl”前缀区分。先看下面这段代码：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdcall <span class="title function_">func</span><span class="params">(<span class="type">int</span> param1,<span class="type">int</span> param2,<span class="type">int</span> param3)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> var1=param1;  </span><br><span class="line">	<span class="type">int</span> var2=param2;  </span><br><span class="line">	<span class="type">int</span> var3=param3;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;param1); <span class="comment">//打印出各个变量的内存地址  </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;param2);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n\n&quot;</span>,&amp;param3);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;var1);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;var2);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n\n&quot;</span>,&amp;var3);  </span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>编译后的执行结果是：  </p>
<p>0x0012ff78<br>0x0012ff7c<br>0x0012ff80  </p>
<p>0x0012ff68<br>0x0012ff6c<br>0x0012ff70  </p>
<p>├———————┤&lt;—函数执行时的栈顶（ESP）、低端内存区域<br>│ …… │<br>├———————┤<br>│ var 1 │<br>├———————┤<br>│ var 2 │<br>├———————┤<br>│ var 3 │<br>├———————┤<br>│ RET │<br>├———————┤&lt;—“<strong>cdecl”函数返回后的栈顶（ESP）<br>│ parameter 1 │<br>├———————┤<br>│ parameter 2 │<br>├———————┤<br>│ parameter 3 │<br>├———————┤&lt;—“</strong>stdcall”函数返回后的栈顶（ESP）<br>│ …… │<br>├———————┤&lt;—栈底（基地址 EBP）、高端内存区域<br>上图就是函数调用过程中堆栈的样子了。</p>
<p>首先，三个参数以从右到左的次序压入堆栈，先压“param3”，再压“param2”，最后压入“param1”；然后压入函数的返回地址(RET)，接着跳转到函数地址接着执行（这里要补充一点，介绍UNIX下的缓冲溢出原理的文章中都提到在压入RET后，继续压入当前EBP，然后用当前ESP代替EBP。然而，有一篇介绍windows下函数调用的文章中说，在windows下的函数调用也有这一步骤，但根据我的实际调试，并未发现这一步，这还可以从param3和var1之间只有4字节的间隙这点看出来）；</p>
<p>第三步，将栈顶(ESP)减去一个数，为本地变量分配内存空间，上例中是减去12字节(ESP=ESP-3<em>4，每个int变量占用4个字节)；接着就初始化本地变量的内存空间。由于“__stdcall”调用由被调函数调整堆栈，所以在函数返回前要恢复堆栈，先回收本地变量占用的内存(ESP=ESP+3</em>4)，然后取出返回地址，填入EIP寄存器，回收先前压入参数占用的内存(ESP=ESP+3*4)，继续执行调用者的代码。参见下列汇编代码：  </p>
<p>;———————func 函数的汇编代码—————————-  </p>
<p>:00401000 83EC0C sub esp, 0000000C //创建本地变量的内存空间<br>:00401003 8B442410 mov eax, dword ptr [esp+10]<br>:00401007 8B4C2414 mov ecx, dword ptr [esp+14]<br>:0040100B 8B542418 mov edx, dword ptr [esp+18]<br>:0040100F 89442400 mov dword ptr [esp], eax<br>:00401013 8D442410 lea eax, dword ptr [esp+10]<br>:00401017 894C2404 mov dword ptr [esp+04], ecx  </p>
<p>……………………（省略若干代码）  </p>
<p>:00401075 83C43C add esp, 0000003C ;恢复堆栈，回收本地变量的内存空间<br>:00401078 C3 ret 000C ;函数返回，恢复参数占用的内存空间<br>;如果是“__cdecl”的话，这里是“ret”，堆栈将由调用者恢复  </p>
<p>;—————————-函数结束————————————-  </p>
<p>;———————主程序调用func函数的代码———————  </p>
<p>:00401080 6A03 push 00000003 //压入参数param3<br>:00401082 6A02 push 00000002 //压入参数param2<br>:00401084 6A01 push 00000001 //压入参数param1<br>:00401086 E875FFFFFF call 00401000 //调用func函数<br>;如果是“__cdecl”的话，将在这里恢复堆栈，“add esp, 0000000C”  </p>
<p>聪明的读者看到这里，差不多就明白缓冲溢出的原理了。先来看下面的代码：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="type">void</span> __stdcall <span class="title function_">func</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">char</span> lpBuff[<span class="number">8</span>]=<span class="string">&quot;\0&quot;</span>;  </span><br><span class="line">	<span class="built_in">strcat</span>(lpBuff,<span class="string">&quot;AAAAAAAAAAA&quot;</span>);  </span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	func();  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>编译后执行一下回怎么样？“”0x00414141”指令引用的”0x00000000”内存。该内存不能为”read”。”，“非法操作””41”就是”A”的16进制的ASCII码了，那明显就是strcat这句出的问题了。”lpBuff”的大小只有8字节，算进结尾的\0，那strcat最多只能写入7个”A”，但程序实际写入了11个”A”外加1个\0。再来看看上面那幅图，多出来的4个字节正好覆盖了RET的所在的内存空间，导致函数返回到一个错误的内存地址，执行了错误的指令。如果能精心构造这个字符串，使它分成三部分，前一部份仅仅是填充的无意义数据以达到溢出的目的，接着是一个覆盖RET的数据，紧接着是一段shellcode，那只要着个RET地址能指向这段shellcode的第一个指令，那函数返回时就能执行shellcode了。但是软件的不同版本和不同的运行环境都可能影响这段shellcode在内存中的位置，那么要构造这个RET是十分困难的。一般都在RET和shellcode之间填充大量的NOP指令，使得exploit有更强的通用性。  </p>
<p>├———————┤&lt;—低端内存区域<br>│ …… │<br>├———————┤&lt;—由exploit填入数据的开始<br>│ │<br>│ buffer │&lt;—填入无用的数据<br>│ │<br>├———————┤<br>│ RET │&lt;—指向shellcode，或NOP指令的范围<br>├———————┤<br>│ NOP │<br>│ …… │&lt;—填入的NOP指令，是RET可指向的范围<br>│ NOP │<br>├———————┤<br>│ │<br>│ shellcode │<br>│ │<br>├———————┤&lt;—由exploit填入数据的结束<br>│ …… │<br>├———————┤&lt;—高端内存区域<br>windows下的动态数据除了可存放在栈中，还可以存放在堆中。了解C++的朋友都知道，C++可以使用new关键字来动态分配内存。来看下面的C++代码：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">char</span> *buffer=new <span class="type">char</span>[<span class="number">128</span>];  </span><br><span class="line">	<span class="type">char</span> bufflocal[<span class="number">128</span>];  </span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> buffstatic[<span class="number">128</span>];  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,buffer); <span class="comment">//打印堆中变量的内存地址  </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,bufflocal); <span class="comment">//打印本地变量的内存地址  </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,buffstatic); <span class="comment">//打印静态变量的内存地址  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	func();  </span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>程序执行结果为：  </p>
<p>0x004107d0<br>0x0012ff04<br>0x004068c0  </p>
<p>可以发现用new关键字分配的内存即不在栈中，也不在静态数据区。VC编译器是通过windows下的“堆(heap)”来实现new关键字的内存动态分配。在讲“堆”之前，先来了解一下和“堆”有关的几个API函数：  </p>
<p>HeapAlloc 在堆中申请内存空间<br>HeapCreate 创建一个新的堆对象<br>HeapDestroy 销毁一个堆对象<br>HeapFree 释放申请的内存<br>HeapWalk 枚举堆对象的所有内存块<br>GetProcessHeap 取得进程的默认堆对象<br>GetProcessHeaps 取得进程所有的堆对象<br>LocalAlloc<br>GlobalAlloc  </p>
<p>当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为1M。堆对象由系统进行管理，它在内存中以链式结构存在。通过下面的代码可以通过堆动态申请内存空间：  </p>
<p>HANDLE hHeap=GetProcessHeap();<br>char *buff=HeapAlloc(hHeap,0,8);  </p>
<p>其中hHeap是堆对象的句柄，buff是指向申请的内存空间的地址。那这个hHeap究竟是什么呢？它的值有什么意义吗？看看下面这段代码吧：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/entry:main&quot;</span>) <span class="comment">//定义程序的入口  </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line">_CRTIMP <span class="title function_">int</span> <span class="params">(__cdecl *<span class="built_in">printf</span>)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, ...)</span>; <span class="comment">//定义STL函数printf  </span></span><br><span class="line"><span class="comment">/*---------------------------------------------------------------------------  </span></span><br><span class="line"><span class="comment">写到这里，我们顺便来复习一下前面所讲的知识：  </span></span><br><span class="line"><span class="comment">(*注)printf函数是C语言的标准函数库中函数，VC的标准函数库由msvcrt.dll模块实现。  </span></span><br><span class="line"><span class="comment">由函数定义可见，printf的参数个数是可变的，函数内部无法预先知道调用者压入的参数个数，函数只能通过分析第一个参数字符串的格式来获得压入参数的信息，由于这里参数的个数是动态的，所以必须由调用者来平衡堆栈，这里便使用了__cdecl调用规则。BTW，Windows系统的API函数基本上是__stdcall调用形式，只有一个API例外，那就是wsprintf，它使用__cdecl调用规则，同printf函数一样，这是由于它的参数个数是可变的缘故。  </span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------*/</span>  </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	HANDLE hHeap=GetProcessHeap();  </span><br><span class="line">	<span class="type">char</span> *buff=HeapAlloc(hHeap,<span class="number">0</span>,<span class="number">0x10</span>);  </span><br><span class="line">	<span class="type">char</span> *buff2=HeapAlloc(hHeap,<span class="number">0</span>,<span class="number">0x10</span>);  </span><br><span class="line">	HMODULE hMsvcrt=LoadLibrary(<span class="string">&quot;msvcrt.dll&quot;</span>);  </span><br><span class="line">	<span class="built_in">printf</span>=(<span class="type">void</span> *)GetProcAddress(hMsvcrt,<span class="string">&quot;printf&quot;</span>);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,hHeap);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,buff);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n\n&quot;</span>,buff2);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>执行结果为：  </p>
<p>0x00130000<br>0x00133100<br>0x00133118  </p>
<p>hHeap的值怎么和那个buff的值那么接近呢？其实hHeap这个句柄就是指向HEAP首部的地址。在进程的用户区存着一个叫PEB(进程环境块)的结构，这个结构中存放着一些有关进程的重要信息，其中在PEB首地址偏移0x18处存放的ProcessHeap就是进程默认堆的地址，而偏移0x90处存放了指向进程所有堆的地址列表的指针。windows有很多API都使用进程的默认堆来存放动态数据，如windows 2000下的所有ANSI版本的函数都是在默认堆中申请内存来转换ANSI字符串到Unicode字符串的。对一个堆的访问是顺序进行的，同一时刻只能有一个线程访问堆中的数据，当多个线程同时有访问要求时，只能排队等待，这样便造成程序执行效率下降。  </p>
<p>最后来说说内存中的数据对齐。所位数据对齐，是指数据所在的内存地址必须是该数据长度的整数倍，DWORD数据的内存起始地址能被4除尽，WORD数据的内存起始地址能被2除尽，x86 CPU能直接访问对齐的数据，当他试图访问一个未对齐的数据时，会在内部进行一系列的调整，这些调整对于程序来说是透明的，但是会降低运行速度，所以编译器在编译程序时会尽量保证数据对齐。同样一段代码，我们来看看用VC、Dev-C++和lcc三个不同编译器编译出来的程序的执行结果：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="type">int</span> a;  </span><br><span class="line">	<span class="type">char</span> b;  </span><br><span class="line">	<span class="type">int</span> c;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;a);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;b);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%08x\n&quot;</span>,&amp;c);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这是用VC编译后的执行结果：<br>0x0012ff7c<br>0x0012ff7b<br>0x0012ff80<br>变量在内存中的顺序：b(1字节)-a(4字节)-c(4字节)。  </p>
<p>这是用Dev-C++编译后的执行结果：<br>0x0022ff7c<br>0x0022ff7b<br>0x0022ff74<br>变量在内存中的顺序：c(4字节)-中间相隔3字节-b(占1字节)-a(4字节)。  </p>
<p>这是用lcc编译后的执行结果：<br>0x0012ff6c<br>0x0012ff6b<br>0x0012ff64<br>变量在内存中的顺序：同上。  </p>
<p>三个编译器都做到了数据对齐，但是后两个编译器显然没VC“聪明”，让一个char占了4字节，浪费内存哦。  </p>
<h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><p>堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称为栈顶，另一端称为栈底，对堆栈的插入和删除操作被称为入栈和出栈。有一组CPU指令可以实现对进程的内存实现堆栈访问。其中，POP指令实现出栈操作，PUSH指令实现入栈操作。CPU的ESP寄存器存放当前线程的栈顶指针，EBP寄存器中保存当前线程的栈底指针。CPU的EIP寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行。  </p>
<p>摘要： 讨论常见的堆性能问题以及如何防范它们。（共 9 页） </p>
<p>前言<br>您是否是动态分配的 C/C++ 对象忠实且幸运的用户？您是否在模块间的往返通信中频繁地使用了“自动化”？您的程序是否因堆分配而运行起来很慢？不仅仅您遇到这样的问题。几乎所有项目迟早都会遇到堆问题。大家都想说，“我的代码真正好，只是堆太慢”。那只是部分正确。更深入理解堆及其用法、以及会发生什么问题，是很有用的。 </p>
<p>什么是堆？<br>（如果您已经知道什么是堆，可以跳到“什么是常见的堆性能问题？”部分） </p>
<p>在程序中，使用堆来动态分配和释放对象。在下列情况下，调用堆操作：  </p>
<p>事先不知道程序所需对象的数量和大小。 </p>
<p>对象太大而不适合堆栈分配程序。<br>堆使用了在运行时分配给代码和堆栈的内存之外的部分内存。下图给出了堆分配程序的不同层。 </p>
<p>GlobalAlloc/GlobalFree：Microsoft Win32 堆调用，这些调用直接与每个进程的默认堆进行对话。 </p>
<p>LocalAlloc/LocalFree：Win32 堆调用（为了与 Microsoft Windows NT 兼容），这些调用直接与每个进程的默认堆进行对话。 </p>
<p>COM 的 IMalloc 分配程序（或 CoTaskMemAlloc / CoTaskMemFree）：函数使用每个进程的默认堆。自动化程序使用“组件对象模型 (COM)”的分配程序，而申请的程序使用每个进程堆。 </p>
<p>C/C++ 运行时 (CRT) 分配程序：提供了 malloc() 和 free() 以及 new 和 delete 操作符。如 Microsoft Visual Basic 和 Java 等语言也提供了新的操作符并使用垃圾收集来代替堆。CRT 创建自己的私有堆，驻留在 Win32 堆的顶部。 </p>
<p>Windows NT 中，Win32 堆是 Windows NT 运行时分配程序周围的薄层。所有 API 转发它们的请求给 NTDLL。 </p>
<p>Windows NT 运行时分配程序提供 Windows NT 内的核心堆分配程序。它由具有 128 个大小从 8 到 1,024 字节的空闲列表的前端分配程序组成。后端分配程序使用虚拟内存来保留和提交页。 </p>
<p>在图表的底部是“虚拟内存分配程序”，操作系统使用它来保留和提交页。所有分配程序使用虚拟内存进行数据的存取。 </p>
<p>分配和释放块不就那么简单吗？为何花费这么长时间？ </p>
<p>堆实现的注意事项<br>传统上，操作系统和运行时库是与堆的实现共存的。<strong>在一个进程的开始，操作系统创建一个默认堆，叫做“进程堆”。如果没有其他堆可使用，则块的分配使用“进程堆”。语言运行时也能在进程内创建单独的堆。</strong>（例如，C 运行时创建它自己的堆。）除这些专用的堆外，应用程序或许多已载入的动态链接库 (DLL) 之一可以创建和使用单独的堆。Win32 提供一整套 API 来创建和使用私有堆。有关堆函数（英文）的详尽指导，请参见 MSDN。 </p>
<p><strong>当应用程序或 DLL 创建私有堆时，这些堆存在于进程空间，并且在进程内是可访问的。从给定堆分配的数据将在同一个堆上释放。（不能从一个堆分配而在另一个堆释放。）</strong> </p>
<p>在所有虚拟内存系统中，堆驻留在操作系统的“虚拟内存管理器”的顶部。语言运行时堆也驻留在虚拟内存顶部。某些情况下，这些堆是操作系统堆中的层，而语言运行时堆则通过大块的分配来执行自己的内存管理。不使用操作系统堆，而使用虚拟内存函数更利于堆的分配和块的使用。 </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">吃饭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/">http://example.com/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">吃饭的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/%E9%97%B4%E8%B0%8D%E8%BF%87%E5%AE%B6%E5%AE%B6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/13/C++%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="/./img/c++%E9%9D%A2%E8%AF%95.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++面试复习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/14/%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/"><img class="next-cover" src="/./img/%E5%AE%B9%E5%99%A8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">播放视频</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">吃饭</div><div class="author-info__description">吃饭比较重要</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinbi-1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinbi-1" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/628931484?spm_id_from=333.934.0.0" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一将功成万骨枯</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">堆和栈的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%E2%80%94%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">一、预备知识—程序的内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="toc-text">二、堆和栈的理论知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">windows进程中的内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-text">基础知识：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/13/C++%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++面试复习笔记"><img src="/./img/c++%E9%9D%A2%E8%AF%95.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++面试复习笔记"/></a><div class="content"><a class="title" href="/2023/01/13/C++%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++面试复习笔记">C++面试复习笔记</a><time datetime="2023-01-13T13:29:10.961Z" title="发表于 2023-01-13 21:29:10">2023-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/" title="理解堆和栈"><img src="/./img/%E9%97%B4%E8%B0%8D%E8%BF%87%E5%AE%B6%E5%AE%B6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="理解堆和栈"/></a><div class="content"><a class="title" href="/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/" title="理解堆和栈">理解堆和栈</a><time datetime="2022-06-01T08:35:05.000Z" title="发表于 2022-06-01 16:35:05">2022-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/14/%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/" title="播放视频"><img src="/./img/%E5%AE%B9%E5%99%A8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="播放视频"/></a><div class="content"><a class="title" href="/2022/04/14/%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/" title="播放视频">播放视频</a><time datetime="2022-04-14T15:29:05.000Z" title="发表于 2022-04-14 23:29:05">2022-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/19/%E6%89%93%E5%8D%A1/" title="打卡记录"><img src="/./img/%E6%89%93%E5%8D%A1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="打卡记录"/></a><div class="content"><a class="title" href="/2022/03/19/%E6%89%93%E5%8D%A1/" title="打卡记录">打卡记录</a><time datetime="2022-03-19T03:06:00.000Z" title="发表于 2022-03-19 11:06:00">2022-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/16/%E5%BC%80%E6%94%BE%E5%AE%B9%E5%99%A8%E5%B9%B6%E9%85%8D%E7%BD%AE/" title="docker容器配置并配置免密登录"><img src="/./img/%E5%AE%B9%E5%99%A8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker容器配置并配置免密登录"/></a><div class="content"><a class="title" href="/2022/03/16/%E5%BC%80%E6%94%BE%E5%AE%B9%E5%99%A8%E5%B9%B6%E9%85%8D%E7%BD%AE/" title="docker容器配置并配置免密登录">docker容器配置并配置免密登录</a><time datetime="2022-03-16T03:35:05.000Z" title="发表于 2022-03-16 11:35:05">2022-03-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 吃饭</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/'
    this.page.identifier = '2022/06/01/理解堆和栈/'
    this.page.title = '理解堆和栈'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?yinbi-1";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="yinbi-1";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"./live2d_models/haruna/33/model.2017.valley.json"},"display":{"position":"left","width":230,"height":400},"mobile":{"show":true},"log":false});</script></body></html>