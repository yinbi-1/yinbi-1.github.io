<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>树专题整理 | 吃饭的博客</title><meta name="author" content="吃饭"><meta name="copyright" content="吃饭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学校Oj的题目整理">
<meta property="og:type" content="article">
<meta property="og:title" content="树专题整理">
<meta property="og:url" content="http://example.com/2022/03/05/%E6%A0%91%E4%B8%93%E9%A2%98%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="吃饭的博客">
<meta property="og:description" content="学校Oj的题目整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/%E6%A0%91.jfif">
<meta property="article:published_time" content="2022-03-05T03:30:05.000Z">
<meta property="article:modified_time" content="2022-03-05T03:49:28.653Z">
<meta property="article:author" content="吃饭">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/%E6%A0%91.jfif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/03/05/%E6%A0%91%E4%B8%93%E9%A2%98%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 吃饭","link":"链接: ","source":"来源: 吃饭的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '树专题整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-05 11:49:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/%E6%A0%91.jfif')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">吃饭的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">树专题整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-05T03:30:05.000Z" title="发表于 2022-03-05 11:30:05">2022-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-05T03:49:28.653Z" title="更新于 2022-03-05 11:49:28">2022-03-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="树专题整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="A-DS二叉树–二叉树构建与遍历"><a href="#A-DS二叉树–二叉树构建与遍历" class="headerlink" title="A. DS二叉树–二叉树构建与遍历"></a>A. DS二叉树–二叉树构建与遍历</h3><p><strong>题目描述</strong><br>给定一颗二叉树的逻辑结构如下图，（先序遍历的结果，空树用字符‘0’表示，例如AB0C00D00），建立该二叉树的二叉链式存储结构，并输出该二叉树的先序遍历、中序遍历和后序遍历结果<br><img src="https://img-blog.csdnimg.cn/dbf6227397654d06a3c460b508d7f901.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD6aWtMjQz,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>输入</strong><br>第一行输入一个整数t，表示有t个二叉树<br>第二行起输入每个二叉树的先序遍历结果，空树用字符‘0’表示，连续输入t行</p>
<p><strong>输出</strong><br>输出每个二叉树的先序遍历、中序遍历和后序遍历结果</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">AB0C00D00</span><br><span class="line">AB00C00</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ABCD</span><br><span class="line">BCAD</span><br><span class="line">CBDA</span><br><span class="line">ABC</span><br><span class="line">BAC</span><br><span class="line">BCA</span><br></pre></td></tr></table></figure>

<hr>
<p>C++ 代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">int pos;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode():left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(char ch):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree(TreeNode* h)&#123;</span><br><span class="line">    char ch =  str[pos++];</span><br><span class="line">    if (ch == &#x27;0&#x27;) return NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">       h = new TreeNode(ch);</span><br><span class="line">       h-&gt;left = make_tree(h-&gt;left);</span><br><span class="line">       h-&gt;right = make_tree(h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(TreeNode* h)&#123;</span><br><span class="line">    cout &lt;&lt; h-&gt;val;</span><br><span class="line">    if (h-&gt;left) PreOrder(h-&gt;left);</span><br><span class="line">    if (h-&gt;right) PreOrder(h-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrder(TreeNode* h)&#123;</span><br><span class="line">    if (h-&gt;left) InOrder(h-&gt;left);</span><br><span class="line">    cout &lt;&lt; h-&gt;val;</span><br><span class="line">    if (h-&gt;right) InOrder(h-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PosOrder(TreeNode* h)&#123;</span><br><span class="line">    if (h-&gt;left) PosOrder(h-&gt;left);</span><br><span class="line">    if (h-&gt;right) PosOrder(h-&gt;right);</span><br><span class="line">    cout &lt;&lt; h-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        TreeNode* head;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        pos = 0;</span><br><span class="line">        head = make_tree(head);</span><br><span class="line">        PreOrder(head);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        InOrder(head);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        PosOrder(head);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="B-DS二叉树–叶子数量"><a href="#B-DS二叉树–叶子数量" class="headerlink" title="B. DS二叉树–叶子数量"></a>B. DS二叉树–叶子数量</h3><p><strong>题目描述</strong><br>计算一颗二叉树包含的叶子结点数量。</p>
<p>提示：叶子是指它的左右孩子为空。</p>
<p>建树方法采用“先序遍历+空树用0表示”的方法，即给定一颗二叉树的先序遍历的结果为AB0C00D00，其中空节点用字符‘0’表示。则该树的逻辑结构如下图。<br><img src="https://img-blog.csdnimg.cn/dfc54ab1484d4e53a3201d9338d6ab1d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD6aWtMjQz,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>输入</strong><br>第一行输入一个整数t，表示有t个测试数据</p>
<p>第二行起输入二叉树先序遍历的结果，空树用字符‘0’表示，输入t行</p>
<p><strong>输出</strong><br>逐行输出每个二叉树的包含的叶子数量</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">AB0C00D00</span><br><span class="line">AB00C00</span><br><span class="line">ABC00D00E00</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">int pos;</span><br><span class="line">int ans;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode():left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(char ch):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree(TreeNode* h)&#123;</span><br><span class="line">    char ch =  str[pos++];</span><br><span class="line">    if (ch == &#x27;0&#x27;) return NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">       h = new TreeNode(ch);</span><br><span class="line">       h-&gt;left = make_tree(h-&gt;left);</span><br><span class="line">       h-&gt;right = make_tree(h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(TreeNode* h)&#123;</span><br><span class="line">    if (h-&gt;left) PreOrder(h-&gt;left);</span><br><span class="line">    if (h-&gt;right) PreOrder(h-&gt;right);</span><br><span class="line">    if (!h-&gt;left &amp;&amp; !h-&gt;right) ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        ans = 0;</span><br><span class="line">        TreeNode* head;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        pos = 0;</span><br><span class="line">        head = make_tree(head);</span><br><span class="line">        PreOrder(head);</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-DS二叉树——二叉树之父子结点"><a href="#C-DS二叉树——二叉树之父子结点" class="headerlink" title="C. DS二叉树——二叉树之父子结点"></a>C. DS二叉树——二叉树之父子结点</h3><p><strong>题目描述</strong></p>
<p>给定一颗二叉树的逻辑结构如下图，（先序遍历的结果，空树用字符‘0’表示，例如AB0C00D00），建立该二叉树的二叉链式存储结构。</p>
<p>编写程序输出该树的所有叶子结点和它们的父亲结点</p>
<p><img src="https://img-blog.csdnimg.cn/0ca625571fae46859c1090a56964cab3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD6aWtMjQz,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>输入</strong><br>第一行输入一个整数t，表示有t个二叉树</p>
<p>第二行起，按照题目表示的输入方法，输入每个二叉树的先序遍历，连续输入t行</p>
<p><strong>输出</strong><br>第一行按先序遍历，输出第1个示例的叶子节点</p>
<p>第二行输出第1个示例中与叶子相对应的父亲节点</p>
<p>以此类推输出其它示例的结果</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">AB0C00D00</span><br><span class="line">AB00C00</span><br><span class="line">ABCD0000EF000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C D </span><br><span class="line">B A </span><br><span class="line">B C </span><br><span class="line">A A </span><br><span class="line">D F </span><br><span class="line">C E </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">string son, fa;</span><br><span class="line">int pos;</span><br><span class="line">int ans;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode():left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(char ch):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree(TreeNode* h)&#123;</span><br><span class="line">    char ch =  str[pos++];</span><br><span class="line">    if (ch == &#x27;0&#x27;) return NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">       h = new TreeNode(ch);</span><br><span class="line">       h-&gt;left = make_tree(h-&gt;left);</span><br><span class="line">       h-&gt;right = make_tree(h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(TreeNode* h)&#123;</span><br><span class="line">    if (h-&gt;left)&#123;</span><br><span class="line">        if (!h-&gt;left-&gt;left &amp;&amp; !h-&gt;left-&gt;right)&#123;</span><br><span class="line">            fa += h-&gt;val;</span><br><span class="line">            son += h-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        PreOrder(h-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (h-&gt;right)&#123;</span><br><span class="line">        if (!h-&gt;right-&gt;left &amp;&amp; !h-&gt;right-&gt;right)&#123;</span><br><span class="line">            fa += h-&gt;val;</span><br><span class="line">            son += h-&gt;right-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        PreOrder(h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        son.clear();</span><br><span class="line">        fa.clear();</span><br><span class="line">        ans = 0;</span><br><span class="line">        TreeNode* head;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        pos = 0;</span><br><span class="line">        head = make_tree(head);</span><br><span class="line">        PreOrder(head);</span><br><span class="line">        for (int i = 0; son[i]; ++i) cout &lt;&lt; son[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        for (int i = 0; fa[i]; ++i) cout &lt;&lt; fa[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-DS树–二叉树高度"><a href="#D-DS树–二叉树高度" class="headerlink" title="D. DS树–二叉树高度"></a>D. DS树–二叉树高度</h3><p><strong>题目描述</strong><br>给出一棵二叉树，求它的高度。二叉树的创建采用前面实验的方法。</p>
<p>注意，二叉树的层数是从1开始</p>
<p><strong>输入</strong><br>第一行输入一个整数t，表示有t个二叉树</p>
<p>第二行起输入每个二叉树的先序遍历结果，空树用字符‘0’表示，连续输入t行</p>
<p><strong>输出</strong><br>每行输出一个二叉树的高度</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">AB0C00D00</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string str;</span><br><span class="line">int pos;</span><br><span class="line">int high;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode():left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(char ch):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree(TreeNode* h)&#123;</span><br><span class="line">    char ch = str[pos++];</span><br><span class="line"></span><br><span class="line">    if (ch == &#x27;0&#x27;) h = NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        h = new TreeNode(ch);</span><br><span class="line">        h-&gt;left = make_tree(h-&gt;left);</span><br><span class="line">        h-&gt;right = make_tree(h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Level(TreeNode* h)&#123;</span><br><span class="line">    TreeNode* q[100];</span><br><span class="line">    int hh = 0, tt = -1;</span><br><span class="line">    q[++tt] = h;</span><br><span class="line"></span><br><span class="line">    while (hh &lt;= tt)&#123;</span><br><span class="line">        int sz = tt-hh + 1;</span><br><span class="line"></span><br><span class="line">        while (sz--)&#123;</span><br><span class="line">            auto t = q[hh++];</span><br><span class="line">            if (t-&gt;left) q[++tt] = t-&gt;left;</span><br><span class="line">            if (t-&gt;right) q[++tt] = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        high++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        pos = 0;</span><br><span class="line">        high = 0;</span><br><span class="line">        TreeNode* head = make_tree(head);</span><br><span class="line">        Level(head);</span><br><span class="line">        cout &lt;&lt; high &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E-DS二叉树——二叉树之数组存储"><a href="#E-DS二叉树——二叉树之数组存储" class="headerlink" title="E. DS二叉树——二叉树之数组存储"></a>E. DS二叉树——二叉树之数组存储</h3><p><strong>题目描述</strong><br>二叉树可以采用数组的方法进行存储，把数组中的数据依次自上而下,自左至右存储到二叉树结点中，一般二叉树与完全二叉树对比，比完全二叉树缺少的结点就在数组中用0来表示。，如下图所示<br><img src="https://img-blog.csdnimg.cn/9a4c13ece0be418d8bdaead9ae2a5b55.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD6aWtMjQz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>从上图可以看出，右边的是一颗普通的二叉树，当它与左边的完全二叉树对比，发现它比完全二叉树少了第5号结点，所以在数组中用0表示，同样它还少了完全二叉树中的第10、11号结点，所以在数组中也用0表示。</p>
<p>结点存储的数据均为非负整数</p>
<p><strong>输入</strong><br>第一行输入一个整数t，表示有t个二叉树</p>
<p>第二行起，每行输入一个数组，先输入数组长度，再输入数组内数据，每个数据之间用空格隔开，输入的数据都是非负整数</p>
<p>连续输入t行</p>
<p><strong>输出</strong><br>每行输出一个示例的先序遍历结果，每个结点之间用空格隔开</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 1 2 3</span><br><span class="line">5 1 2 3 0 4</span><br><span class="line">13 1 2 3 4 0 5 6 7 8 0 0 9 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">1 2 4 3 </span><br><span class="line">1 2 4 7 8 3 5 9 10 6 </span><br></pre></td></tr></table></figure>
<hr>
<p><strong>提示</strong><br>注意从数组位置和二叉树深度、结点位置进行关联，或者父子结点在数组中的位置存在某种管理，例如i, i+1, i&#x2F;2,  i+1&#x2F;2……..或者2i, 2i+1…….仔细观察哦</p>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">int n;</span><br><span class="line">int nums[N];</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode():val(-1), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(int x):val(x), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree(int u)&#123;</span><br><span class="line">    TreeNode* t;</span><br><span class="line">    if (nums[u] == 0) t = NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        t = new TreeNode(nums[u]);</span><br><span class="line">        if (2*u &lt;= n) t-&gt;left = make_tree(2*u);</span><br><span class="line">        if (2*u+1 &lt;= n) t-&gt;right = make_tree(2*u+1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(TreeNode* h)&#123;</span><br><span class="line">    cout &lt;&lt; h-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    if (h-&gt;left) PreOrder(h-&gt;left);</span><br><span class="line">    if (h-&gt;right) PreOrder(h-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; nums[i];</span><br><span class="line">        TreeNode* head;</span><br><span class="line">        head = make_tree(1);</span><br><span class="line">        PreOrder(head);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F-DS二叉树–赫夫曼树的构建与编码（含代码框架）"><a href="#F-DS二叉树–赫夫曼树的构建与编码（含代码框架）" class="headerlink" title="F. DS二叉树–赫夫曼树的构建与编码（含代码框架）"></a>F. DS二叉树–赫夫曼树的构建与编码（含代码框架）</h3><p><strong>题目描述</strong><br>给定n个权值，根据这些权值构造huffman树，并进行huffman编码</p>
<p>参考课本算法，注意数组访问是从位置1开始</p>
<p>要求：赫夫曼的构建中，默认左孩子权值不大于右孩子权值</p>
<p>代码框架参考如下：<br><img src="https://img-blog.csdnimg.cn/1309cca8e1d543bd889a23f84d07a890.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD6aWtMjQz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>输入</strong><br>第一行输入t，表示有t个测试实例<br>第二行先输入n，表示第1个实例有n个权值，接着输入n个权值，权值全是小于1万的正整数<br>依此类推</p>
<p><strong>输出</strong><br>逐行输出每个权值对应的编码，格式如下：权值-编码<br>即每行先输出1个权值，再输出一个短划线，再输出对应编码，接着下一行输入下一个权值和编码。<br>以此类推</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5 15 4 4 3 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">15-1</span><br><span class="line">4-010</span><br><span class="line">4-011</span><br><span class="line">3-001</span><br><span class="line">2-000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+10;</span><br><span class="line">int n;</span><br><span class="line">int a[N];</span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode(int id = 0, int val = 0):id(id), val(val)&#123;&#125;</span><br><span class="line">    bool operator &lt; (const TreeNode &amp;r) const&#123;</span><br><span class="line">        if (val == r.val) return id &gt; r.id;</span><br><span class="line">        return val &gt; r.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Tree&#123;</span><br><span class="line">    int lch;</span><br><span class="line">    int rch;</span><br><span class="line">&#125;tree[N];</span><br><span class="line"></span><br><span class="line">string str[N];</span><br><span class="line"></span><br><span class="line">void dfs(int u, string path)&#123;</span><br><span class="line">    if (u == -1) return ;</span><br><span class="line">    if (u &lt; n) str[u] = path;</span><br><span class="line">    dfs(tree[u].lch, path + &#x27;0&#x27;);</span><br><span class="line">    dfs(tree[u].rch, path+&#x27;1&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        priority_queue&lt;TreeNode&gt; heap;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            heap.push(TreeNode(i, a[i]));</span><br><span class="line">            tree[i].lch = tree[i].rch = -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt = n-1;</span><br><span class="line"></span><br><span class="line">        while (!heap.empty())&#123;</span><br><span class="line">            bool two = false;</span><br><span class="line">            TreeNode op[2];</span><br><span class="line">            if (!heap.empty())&#123;</span><br><span class="line">                op[0] = heap.top();</span><br><span class="line">                heap.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if (!heap.empty())&#123;</span><br><span class="line">                op[1] = heap.top();</span><br><span class="line">                heap.pop();</span><br><span class="line">                two = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!two) break;</span><br><span class="line"></span><br><span class="line">            heap.push(TreeNode(++cnt, op[0].val+op[1].val));</span><br><span class="line">            tree[cnt].lch = op[0].id;</span><br><span class="line">            tree[cnt].rch = op[1].id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(cnt, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; ++i) cout &lt;&lt; a[i] &lt;&lt; &quot;-&quot; &lt;&lt; str[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="G-DS二叉树–赫夫曼树解码（含代码框架）"><a href="#G-DS二叉树–赫夫曼树解码（含代码框架）" class="headerlink" title="G. DS二叉树–赫夫曼树解码（含代码框架）"></a>G. DS二叉树–赫夫曼树解码（含代码框架）</h3><p><strong>题目描述</strong><br>已知赫夫曼编码算法和程序，在此基础上进行赫夫曼解码</p>
<p>在赫夫曼树的类定义中增加了一个公有方法：</p>
<p>int  Decode(const string codestr, char txtstr[]);&#x2F;&#x2F;输入编码串codestr，输出解码串txtstr</p>
<p>该方法如果解码成功则返回1，解码失败则返回-1，本程序增加宏定义ok表示1，error表示-1</p>
<p>解码方法的代码框架如下：<br><img src="https://img-blog.csdnimg.cn/785296913c8f47dd831064036c51e318.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD6aWtMjQz,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>输入</strong><br>第一行输入t，表示有t个测试实例<br>第二行先输入n，表示第1个实例有n个权值，接着输入n个权值，权值全是小于1万的正整数<br>第三行输入n个字母，表示与权值对应的字符<br>第四行输入k，表示要输入k个编码串<br>第五行起输入k个编码串<br>以此类推输入下一个示例</p>
<p><strong>输出</strong><br>每行输出解码后的字符串，如果解码失败直接输出字符串“error”，不要输出部分解码结果</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 15 4 4 3 2</span><br><span class="line">A B C D E</span><br><span class="line">3</span><br><span class="line">11111</span><br><span class="line">10100001001</span><br><span class="line">00000101100</span><br><span class="line">4 7 5 2 4</span><br><span class="line">A B C D</span><br><span class="line">3</span><br><span class="line">1010000</span><br><span class="line">111011</span><br><span class="line">111110111</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AAAAA</span><br><span class="line">ABEAD</span><br><span class="line">error</span><br><span class="line">BBAAA</span><br><span class="line">error</span><br><span class="line">DCD</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 5;</span><br><span class="line"></span><br><span class="line">int cnt, a[N], n;</span><br><span class="line">char ch[N];</span><br><span class="line">struct Tree &#123;</span><br><span class="line">    int lch, rch;</span><br><span class="line">&#125;t[N&lt;&lt;1];</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">    int id, val;</span><br><span class="line">    node(int id=0, int v=0): id(id), val(v) &#123;&#125;</span><br><span class="line">    bool operator &lt; (const node&amp; r) const &#123;</span><br><span class="line">        if (val == r.val) return id &gt; r.id;</span><br><span class="line">        return val &gt; r.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">string s[N], str, ans;</span><br><span class="line"></span><br><span class="line">void dfs(int u, string path) &#123;</span><br><span class="line">    if (u == -1) return ;</span><br><span class="line">    if (u &lt;= n) s[u] = path;</span><br><span class="line">    dfs(t[u].lch, path + &quot;0&quot;);</span><br><span class="line">    dfs(t[u].rch, path + &quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Decode(int u, int c, string&amp; ans) &#123;</span><br><span class="line">    if (u == - 1) return;</span><br><span class="line">    if (u &lt;= n &amp;&amp; str[c]) &#123;</span><br><span class="line">        ans += ch[u];</span><br><span class="line">        Decode(cnt, c, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    if (str[c] == 0) &#123;</span><br><span class="line">        if (u &gt; n) &#123;</span><br><span class="line">            ans = &quot;error&quot;;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            ans += ch[u];</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (str[c] == &#x27;1&#x27;) Decode(t[u].rch, c+1, ans);</span><br><span class="line">    if (str[c] == &#x27;0&#x27;) Decode(t[u].lch, c+1, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T; cin &gt;&gt; T;</span><br><span class="line">    while (T --) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        priority_queue&lt;node&gt; q;</span><br><span class="line">        for (int i = 1; i &lt;= n; i ++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            q.push(node(i, a[i]));</span><br><span class="line">            t[i].lch = t[i].rch = -1;</span><br><span class="line">            s[i] = &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; ch[i];</span><br><span class="line">        cnt = n;</span><br><span class="line">        while (! q.empty()) &#123;</span><br><span class="line">            bool two = false;</span><br><span class="line">            node op[2];</span><br><span class="line">            if (! q.empty()) &#123;</span><br><span class="line">                op[0] = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            if (! q.empty()) &#123;</span><br><span class="line">                op[1] = q.top();</span><br><span class="line">                q.pop(), two = true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (! two) break;</span><br><span class="line">            q.push(node(++ cnt, op[1].val + op[0].val));</span><br><span class="line">            t[cnt].lch = op[0].id, t[cnt].rch = op[1].id;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(cnt, &quot;&quot;);</span><br><span class="line">        int k; cin &gt;&gt; k;</span><br><span class="line">        for (int i = 0; i &lt; k; i ++) &#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            Decode(cnt, 0, ans=&quot;&quot;);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="H-DS树–带权路径和"><a href="#H-DS树–带权路径和" class="headerlink" title="H. DS树–带权路径和"></a>H. DS树–带权路径和</h3><p><strong>题目描述</strong><br>计算一棵二叉树的带权路径总和，即求赫夫曼树的带权路径和。</p>
<p>已知一棵二叉树的叶子权值，该二叉树的带权案路径和APL等于叶子权值乘于根节点到叶子的分支数，然后求总和。如下图中，叶子都用大写字母表示，权值对应为：A-7，B-6，C-2，D-3</p>
<p>树的带权路径和 &#x3D; 7<em>1 + 6</em>2 + 2<em>3 + 3</em>3 &#x3D; 34<br><img src="https://img-blog.csdnimg.cn/24546610229d406c89fe2a88f9c5f814.png" alt="在这里插入图片描述"><br>本题二叉树的创建参考前面的方法</p>
<p><strong>输入</strong><br>第一行输入一个整数t，表示有t个二叉树</p>
<p>第二行输入一棵二叉树的先序遍历结果，空树用字符‘0’表示，注意输入全是英文字母和0，其中大写字母表示叶子</p>
<p>第三行先输入n表示有n个叶子，接着输入n个数据表示n个叶子的权值，权值的顺序和前面输入的大写字母顺序对应</p>
<p>以此类推输入下一棵二叉树</p>
<p><strong>输出</strong><br>输出每一棵二叉树的带权路径和</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">xA00tB00zC00D00</span><br><span class="line">4 7 6 2 3</span><br><span class="line">ab0C00D00</span><br><span class="line">2 10 20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">34</span><br><span class="line">40</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string str;</span><br><span class="line">int pos;</span><br><span class="line">int sum;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(char val = 0):val(val), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree()&#123;</span><br><span class="line">    char ch = str[pos++];</span><br><span class="line">    TreeNode* h;</span><br><span class="line">    if (ch == &#x27;0&#x27;) h = NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        h = new TreeNode(ch);</span><br><span class="line">        h-&gt;left = make_tree();</span><br><span class="line">        h-&gt;right = make_tree();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(TreeNode* h, int u)&#123;</span><br><span class="line">    if (h-&gt;left) PreOrder(h-&gt;left, u+1);</span><br><span class="line">    if (h-&gt;right) PreOrder(h-&gt;right, u+1);</span><br><span class="line">    if (!h-&gt;left &amp;&amp; !h-&gt;right)&#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        sum += x*u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        sum = 0;</span><br><span class="line">        pos = 0;</span><br><span class="line">        TreeNode* head;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        head = make_tree();</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt;x;</span><br><span class="line">        PreOrder(head, 0);</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I-DS二叉树–基于数组存储的构建"><a href="#I-DS二叉树–基于数组存储的构建" class="headerlink" title="I. DS二叉树–基于数组存储的构建"></a>I. DS二叉树–基于数组存储的构建</h3><p><strong>题目描述</strong><br>任意二叉树可以根据完全二叉树性质保存在一个数组中。已知二叉树的数组存储，用程序构建该二叉树。</p>
<p>提示：用递归方法或非递归都可以</p>
<p>递归方法的代码框架如下：<br><img src="https://img-blog.csdnimg.cn/8b2bfcdf03b64d5c9faadae15e3e67fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD6aWtMjQz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>输入</strong><br>第一行输入一个整数t，表示有t个测试数据</p>
<p>第二行起输入二叉树的数组存储结果，空树用字符‘0’表示，输入t行</p>
<p>数组的数据由大写字母和0表示</p>
<p><strong>输出</strong><br>逐行输出每个二叉树的先序结果</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">ABC0D</span><br><span class="line">ABCDEF000G</span><br><span class="line">ABEC0F0D0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ABDC</span><br><span class="line">ABDEGCF</span><br><span class="line">ABCDEF</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(char ch = 0):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree(int u)&#123;</span><br><span class="line">    char ch = str[u];</span><br><span class="line">    TreeNode* h;</span><br><span class="line">    if (ch == &#x27;0&#x27;) h = NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        h = new TreeNode(ch);</span><br><span class="line">        if (2*u &lt; str.size()) h-&gt;left = make_tree(2*u);</span><br><span class="line">        if (2*u+1 &lt; str.size()) h-&gt;right = make_tree(2*u+1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(TreeNode* h)&#123;</span><br><span class="line">    cout &lt;&lt; h-&gt;val;</span><br><span class="line">    if (h-&gt;left) PreOrder(h-&gt;left);</span><br><span class="line">    if (h-&gt;right) PreOrder(h-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        TreeNode* head;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        str.insert(str.begin(), &#x27; &#x27;);</span><br><span class="line">        head = make_tree(1);</span><br><span class="line">        PreOrder(head);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="J-DS二叉树判断–同一棵二叉树？"><a href="#J-DS二叉树判断–同一棵二叉树？" class="headerlink" title="J. DS二叉树判断–同一棵二叉树？"></a>J. DS二叉树判断–同一棵二叉树？</h3><p><strong>题目描述</strong><br>二叉树分别以数组存储方式创建、以先序遍历序列创建。输入二叉树的数组存储、先序遍历结果，判断根据它们创建的二叉树是否是同一棵二叉树。</p>
<p><strong>输入</strong><br>测试次数t</p>
<p>每组测试数据两行：</p>
<p>第一行：二叉树的数组存储（英文字母表示树结点，#表示空树）</p>
<p>第二行：二叉树的先序遍历结果(英文字母表示树结点，#表示空树）</p>
<p><strong>输出</strong><br>对每组测试数据，如果两种方式创建的是同一棵二叉树，输出YES，否则，输出NO。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">ABCDE</span><br><span class="line">ABD##E##C</span><br><span class="line">ABC##DE####W##F</span><br><span class="line">AB##CDW###E#F##</span><br><span class="line">abc##d</span><br><span class="line">ab##c#d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">NO</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string str;</span><br><span class="line">int pos;</span><br><span class="line">bool flag;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(char ch = 0):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree(int u)&#123;</span><br><span class="line">    char ch = str[u];</span><br><span class="line">    TreeNode* h;</span><br><span class="line">    if (ch == &#x27;#&#x27;) h = NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        h = new TreeNode(ch);</span><br><span class="line">        if (2*u &lt; str.size()) h-&gt;left = make_tree(2*u);</span><br><span class="line">        if (2*u+1 &lt; str.size()) h-&gt;right = make_tree(2*u+1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(TreeNode* h)&#123;</span><br><span class="line">    if (h)&#123;</span><br><span class="line">        if (h-&gt;val != str[pos++]) flag = false;</span><br><span class="line">        PreOrder(h-&gt;left);</span><br><span class="line">        PreOrder(h-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (pos &lt; str.size() &amp;&amp; str[pos++] != &#x27;#&#x27;) flag = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        flag = true;</span><br><span class="line">        pos = 0;</span><br><span class="line">        TreeNode* head;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        str.insert(str.begin(), &#x27; &#x27;);</span><br><span class="line">        head = make_tree(1);</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        PreOrder(head);</span><br><span class="line">        if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="K-DS树–二叉树之最大路径"><a href="#K-DS树–二叉树之最大路径" class="headerlink" title="K. DS树–二叉树之最大路径"></a>K. DS树–二叉树之最大路径</h3><p><strong>题目描述</strong><br>给定一颗二叉树的逻辑结构（先序遍历的结果，空树用字符‘0’表示，例如AB0C00D00），建立该二叉树的二叉链式存储结构</p>
<p>二叉树的每个结点都有一个权值，从根结点到每个叶子结点将形成一条路径，每条路径的权值等于路径上所有结点的权值和。编程求出二叉树的最大路径权值。如下图所示，共有4个叶子即有4条路径，</p>
<p>路径1权值&#x3D;5 + 4 + 11 + 7 &#x3D; 27路径2权值&#x3D;5 + 4 + 11 + 2 &#x3D; 22</p>
<p>路径3权值&#x3D;5 + 8 + 13 &#x3D; 26路径4权值&#x3D;5 + 8 + 4 + 1 &#x3D; 18</p>
<p>可计算出最大路径权值是27。</p>
<p>该树输入的先序遍历结果为ABCD00E000FG00H0I00，各结点权值为：</p>
<p>A-5，B-4，C-11，D-7，E-2，F-8，G-13，H-4，I-1<br><img src="https://img-blog.csdnimg.cn/3bfcaccdfcc94da9be60e38344b72db1.png" alt="在这里插入图片描述"></p>
<p><strong>输入</strong><br>第一行输入一个整数t，表示有t个测试数据</p>
<p>第二行输入一棵二叉树的先序遍历，每个结点用字母表示</p>
<p>第三行先输入n表示二叉树的结点数量，然后输入每个结点的权值，权值顺序与前面结点输入顺序对应</p>
<p>以此类推输入下一棵二叉树</p>
<p><strong>输出</strong><br>每行输出每棵二叉树的最大路径权值，如果最大路径权值有重复，只输出1个</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">AB0C00D00</span><br><span class="line">4 5 3 2 6</span><br><span class="line">ABCD00E000FG00H0I00</span><br><span class="line">9 5 4 11 7 2 8 13 4 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">27</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string str;</span><br><span class="line">int pos;</span><br><span class="line">int sum;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char ch;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(int val = 0, char ch = 0):val(val), ch(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree()&#123;</span><br><span class="line">    char ch = str[pos++];</span><br><span class="line">    TreeNode* h;</span><br><span class="line">    if (ch == &#x27;0&#x27;) h = NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        h = new TreeNode(x, ch);</span><br><span class="line">        h-&gt;left = make_tree();</span><br><span class="line">        h-&gt;right = make_tree();</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(TreeNode* h, int u)&#123;</span><br><span class="line">    if (h-&gt;left) dfs(h-&gt;left, u+h-&gt;val);</span><br><span class="line">    if (h-&gt;right) dfs(h-&gt;right, u+h-&gt;val);</span><br><span class="line">    if (!h-&gt;left &amp;&amp; !h-&gt;right) sum = max(u+h-&gt;val, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        sum = 0;</span><br><span class="line">        pos = 0;</span><br><span class="line">        TreeNode* head;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        head = make_tree();</span><br><span class="line">        dfs(head, 0);</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="L-DS森林叶子编码"><a href="#L-DS森林叶子编码" class="headerlink" title="L. DS森林叶子编码"></a>L. DS森林叶子编码</h3><p><strong>题目描述</strong><br>给定一组森林，编写程序生成对应的二叉树，输出这颗二叉树叶结点对应的二进制编码.规定二叉树的左边由0表示，二叉树的右边由1表示。</p>
<p><strong>输入</strong><br>N B  表示N个树，每结点最多B个分支</p>
<p>第2行至第N+1行，每个树的先序遍历</p>
<p><strong>输出</strong><br>每行表示一个叶结点对应的二进制编码.</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">A B 0 0 0 C 0 0 0 D 0 0 0</span><br><span class="line">E F 0 0 0 0 0</span><br><span class="line">G H 0 0 0 I J 0 0 0 0 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 1 1</span><br><span class="line">1 0</span><br><span class="line">1 1 0 1 0</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, nums;</span><br><span class="line">string s;</span><br><span class="line">string temp;</span><br><span class="line">int pos;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode** child;</span><br><span class="line">    TreeNode(char val = 0):val(val)&#123;</span><br><span class="line">        child = new TreeNode*[nums];</span><br><span class="line">        for (int i = 0; i &lt; nums; ++i)&#123;</span><br><span class="line">            child[i] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct BiNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    BiNode* left;</span><br><span class="line">    BiNode* right;</span><br><span class="line">    BiNode(char ch = 0):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree()&#123;</span><br><span class="line">    TreeNode* h;</span><br><span class="line">    char ch;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    if (ch == &#x27;0&#x27;) h = NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        h = new TreeNode(ch);</span><br><span class="line">        for (int i = 0; i &lt; nums; ++i)&#123;</span><br><span class="line">            h-&gt;child[i] = make_tree();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BiNode* trans(TreeNode* h)&#123;</span><br><span class="line">    BiNode* t = NULL;</span><br><span class="line">    if (h != NULL)&#123;</span><br><span class="line">        t = new BiNode(h-&gt;val);</span><br><span class="line">        t-&gt;left = trans(h-&gt;child[0]);</span><br><span class="line">        if (t-&gt;left)&#123;</span><br><span class="line">            BiNode* tt = t-&gt;left;</span><br><span class="line">            for (int i = 1; i &lt; nums; ++i)&#123;</span><br><span class="line">                tt-&gt;right = trans(h-&gt;child[i]);</span><br><span class="line">                if (tt-&gt;right) tt = tt-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(BiNode* h, string path)&#123;</span><br><span class="line">    if (h-&gt;left) dfs(h-&gt;left, path + &#x27;0&#x27;);</span><br><span class="line">    if (h-&gt;right) dfs(h-&gt;right, path + &#x27;1&#x27;);</span><br><span class="line">    if (!h-&gt;left &amp;&amp; !h-&gt;right)&#123;</span><br><span class="line">        int x = path.size();</span><br><span class="line">        for (int i = 0; i &lt; x; ++i)&#123;</span><br><span class="line">            if (i &lt; x-1) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">            else cout &lt;&lt; path[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; nums;</span><br><span class="line">    TreeNode** head;</span><br><span class="line">    head = new TreeNode*[n];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">        head[i] = make_tree();</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode** h;</span><br><span class="line">    h = new BiNode*[n];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">        h[i] = trans(head[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i)&#123;</span><br><span class="line">        h[i-1]-&gt;right = h[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(h[0], &quot;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="M-DS二叉树—二叉树结点的最大距离"><a href="#M-DS二叉树—二叉树结点的最大距离" class="headerlink" title="M. DS二叉树—二叉树结点的最大距离"></a>M. DS二叉树—二叉树结点的最大距离</h3><p><strong>题目描述</strong><br>二叉树两个结点的距离是一个结点经过双亲结点，祖先结点等中间结点到达另一个结点经过的分支数。二叉树结点的最大距离是所有结点间距离的最大值。例如，下图所示二叉树结点最大距离是3，C和D的距离。</p>
<p>二叉树用先序遍历顺序创建，#表示空树。计算二叉树结点最大距离和最大距离的两个结点(假设二叉树中取最大距离的两个结点唯一）。<br><img src="https://img-blog.csdnimg.cn/9506983494a04d2a84ab80e6de85f865.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZCD6aWtMjQz,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>输入</strong><br>测试次数T</p>
<p>第2行之后的T行，每行为一棵二叉树先序遍历结果（#表示空树）</p>
<p><strong>输出</strong><br>对每棵二叉树，输出树的结点最大距离和最大距离的结点，输出格式见样例。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">A##</span><br><span class="line">ABC##EF#G###D##</span><br><span class="line">ABEH###F#K###</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:</span><br><span class="line">5:G D</span><br><span class="line">4:H K</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int depth;</span><br><span class="line">char temp;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode():left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">    TreeNode(char ch):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Tree&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* root;</span><br><span class="line">    int pos;</span><br><span class="line">    int ld;</span><br><span class="line">    int rd;</span><br><span class="line">    char l;</span><br><span class="line">    char ll;</span><br><span class="line">    char rr;</span><br><span class="line">    char r;</span><br><span class="line">    int maxn;</span><br><span class="line">    string str;</span><br><span class="line">    Tree():pos(0), ld(0), rd(0), maxn(0)&#123;&#125;</span><br><span class="line">    ~Tree()&#123;&#125;</span><br><span class="line">    void MakeTree(string s)&#123;</span><br><span class="line">        str += s;</span><br><span class="line">        root = MakeTree();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* MakeTree()&#123;</span><br><span class="line">        char ch = str[pos++];</span><br><span class="line">        TreeNode* t;</span><br><span class="line">        if (ch == &#x27;#&#x27;) return NULL;</span><br><span class="line">        else &#123;</span><br><span class="line">            t = new TreeNode(ch);</span><br><span class="line">            t-&gt;left = MakeTree();</span><br><span class="line">            t-&gt;right = MakeTree();</span><br><span class="line">        &#125;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void LDepth(TreeNode* root)&#123;</span><br><span class="line">        if (root-&gt;left == NULL)&#123;</span><br><span class="line">            depth = 0;</span><br><span class="line">            temp = root-&gt;val;</span><br><span class="line">            l = temp;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        Depth(root-&gt;left, 0);</span><br><span class="line">        ld = depth;</span><br><span class="line">        l = temp;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void RDepth(TreeNode* root)&#123;</span><br><span class="line">        if (root-&gt;right == NULL)&#123;</span><br><span class="line">            depth = 0;</span><br><span class="line">            temp = root-&gt;val;</span><br><span class="line">            r = temp;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        Depth(root-&gt;right, 0);</span><br><span class="line">        rd = depth;</span><br><span class="line">        r = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Depth(TreeNode* root, int sum)&#123;</span><br><span class="line">        if (root != NULL)&#123;</span><br><span class="line">             sum++;</span><br><span class="line">             if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; depth &lt; sum)&#123;</span><br><span class="line">                 depth = sum;</span><br><span class="line">                 temp = root-&gt;val;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (root-&gt;left) Depth(root-&gt;left, sum);</span><br><span class="line">             if (root-&gt;right) Depth(root-&gt;right, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void PreOrder(TreeNode* root)&#123;</span><br><span class="line">        if (root != NULL)&#123;</span><br><span class="line">            depth = 0;</span><br><span class="line">            ld = 0;</span><br><span class="line">            LDepth(root);</span><br><span class="line">            depth = 0;</span><br><span class="line">            rd = 0;</span><br><span class="line">            RDepth(root);</span><br><span class="line">            if (maxn &lt; ld+rd)&#123;</span><br><span class="line">                ll = l;</span><br><span class="line">                rr = r;</span><br><span class="line">                maxn = ld+rd;</span><br><span class="line">                //cout &lt;&lt; maxn &lt;&lt; ll &lt;&lt; &quot; &quot; &lt;&lt; rr &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            PreOrder(root-&gt;left);</span><br><span class="line">            PreOrder(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        string str;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        Tree t;</span><br><span class="line">        t.MakeTree(str);</span><br><span class="line">        t.LDepth(t.root);</span><br><span class="line">        t.RDepth(t.root);</span><br><span class="line">        t.PreOrder(t.root);</span><br><span class="line">        if (t.maxn == 0) cout &lt;&lt; &quot;0:&quot; &lt;&lt; endl;</span><br><span class="line">        else cout &lt;&lt; t.maxn &lt;&lt; &quot;:&quot; &lt;&lt; t.ll &lt;&lt; &quot; &quot; &lt;&lt; t.rr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DS二叉树—二叉树镜面反转"><a href="#DS二叉树—二叉树镜面反转" class="headerlink" title="DS二叉树—二叉树镜面反转"></a>DS二叉树—二叉树镜面反转</h3><p><strong>题目描述</strong><br>假设二叉树用二叉链表存储，用先序序列结果创建。输入二叉树的先序序列，请你先创建二叉树，并对树做个镜面反转，再输出反转后的二叉树的先序遍历、中序遍历、后序遍历和层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。</p>
<p>–程序要求–<br>若使用C++只能include一个头文件iostream；若使用C语言只能include一个头文件stdio<br>程序中若include多过一个头文件，不看代码，作0分处理<br>不允许使用第三方对象或函数实现本题的要求</p>
<p><strong>输入</strong><br>测试次数t</p>
<p>每组测试数据是一个二叉树的先序遍历序列，#表示空树</p>
<p><strong>输出</strong><br>对每棵二叉树，输出镜面反转后的先序、中序、后序和层次遍历序列。如果空树，输出四个NULL（后面不加空格）。如下：</p>
<p>NULL</p>
<p>NULL</p>
<p>NULL</p>
<p>NULL</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">41#32###65##7##</span><br><span class="line">AB#C##D##</span><br><span class="line">AB##C##</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 6 7 5 1 3 2 </span><br><span class="line">7 6 5 4 3 2 1 </span><br><span class="line">7 5 6 2 3 1 4 </span><br><span class="line">4 6 1 7 5 3 2 </span><br><span class="line">A D B C </span><br><span class="line">D A C B </span><br><span class="line">D C B A </span><br><span class="line">A D B C </span><br><span class="line">A C B </span><br><span class="line">C A B </span><br><span class="line">C B A </span><br><span class="line">A C B </span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line">int pos;</span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    char val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(char ch = 0):val(ch), left(NULL), right(NULL)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* make_tree()&#123;</span><br><span class="line">    char ch = str[pos++];</span><br><span class="line">    TreeNode* t;</span><br><span class="line">    if (ch == &#x27;#&#x27;) return NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        t = new TreeNode(ch);</span><br><span class="line">        t-&gt;left = make_tree();</span><br><span class="line">        t-&gt;right = make_tree();</span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode* trans(TreeNode* h)&#123;</span><br><span class="line">    if (h == NULL) return NULL;</span><br><span class="line">    TreeNode* s;</span><br><span class="line">    s = new TreeNode(h-&gt;val);</span><br><span class="line">    if (h-&gt;left) s-&gt;right = trans(h-&gt;left);</span><br><span class="line">    if (h-&gt;right) s-&gt;left = trans(h-&gt;right);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PreOrder(TreeNode* h)&#123;</span><br><span class="line">    cout &lt;&lt; h-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    if (h-&gt;left) PreOrder(h-&gt;left);</span><br><span class="line">    if (h-&gt;right) PreOrder(h-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InOrder(TreeNode* h)&#123;</span><br><span class="line">    if (h-&gt;left) InOrder(h-&gt;left);</span><br><span class="line">    cout &lt;&lt; h-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">    if (h-&gt;right) InOrder(h-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PosOrder(TreeNode* h)&#123;</span><br><span class="line">    if (h-&gt;left) PosOrder(h-&gt;left);</span><br><span class="line">    if (h-&gt;right) PosOrder(h-&gt;right);</span><br><span class="line">    cout &lt;&lt; h-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Level(TreeNode* h)&#123;</span><br><span class="line">    TreeNode* q[100];</span><br><span class="line">    int hh = 0, tt = -1;</span><br><span class="line">    q[++tt] = h;</span><br><span class="line">    while (hh &lt;= tt)&#123;</span><br><span class="line">        int sz = tt-hh+1;</span><br><span class="line"></span><br><span class="line">        while (sz--)&#123;</span><br><span class="line">            auto t = q[hh++];</span><br><span class="line">            cout &lt;&lt; t-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">            if (t-&gt;left) q[++tt] = t-&gt;left;</span><br><span class="line">            if (t-&gt;right) q[++tt] = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--)&#123;</span><br><span class="line">        pos = 0;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        TreeNode* h = make_tree();</span><br><span class="line">        TreeNode* s = trans(h);</span><br><span class="line">        if (s == NULL)&#123;</span><br><span class="line">            for (int i = 0; i &lt; 4; ++i) cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            PreOrder(s);</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            InOrder(s);</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            PosOrder(s);</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            Level(s);</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="O-DS树–找出直系亲属"><a href="#O-DS树–找出直系亲属" class="headerlink" title="O. DS树–找出直系亲属"></a>O. DS树–找出直系亲属</h3><p><strong>题目描述</strong><br>如果A，B是C的父母亲，则A，B是C的parent，C是A，B的child，如果A，B是C的（外）祖父，祖母，则A，B是C的grandparent，C是A，B的grandchild，如果A，B是C的（外）曾祖父，曾祖母，则A，B是C的great-grandparent，C是A，B的great-grandchild，之后再多一辈，则在关系上加一个great-</p>
<p><strong>输入</strong><br>输入包含多组测试用例,每组用例首先包含2个整数n（0&lt;&#x3D;n&lt;&#x3D;26）和m（0&lt;m&lt;50）, 分别表示有n个亲属关系和m个问题, 然后接下来是n行的形式如ABC的字符串，表示A的父母亲分别是B和C，如果A的父母亲信息不全，则用-代替，例如A-C,再然后是m行形式如FA的字符串,表示询问F和A的关系。<br>当n和m为0时结束输入。</p>
<p><strong>输出</strong><br>如果询问的2个人是直系亲属，请按题目描述输出2者的关系，如果没有直系关系，请输出-。<br>具体含义和输出格式参见样例.</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">ABC</span><br><span class="line">CDE</span><br><span class="line">EFG</span><br><span class="line">FA</span><br><span class="line">BE</span><br><span class="line">0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">great-grandparent</span><br><span class="line">-</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>C++ 代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#define N 26</span><br><span class="line">using namespace std;</span><br><span class="line">class Node</span><br><span class="line">&#123;//二叉树节点</span><br><span class="line">public:</span><br><span class="line">    int p1;//第一个双亲的下标，-1表示不存在</span><br><span class="line">    int p2;//第二个双亲的下标，-1表示不存在</span><br><span class="line">&#125;;</span><br><span class="line">int preOrder(Node *tree,int from, int to, int depth)</span><br><span class="line">&#123;//从from出发先序遍历到找到to为止，并返回to相对于from的深度</span><br><span class="line">    if(from==to)</span><br><span class="line">        return depth;</span><br><span class="line">    if(tree[from].p1!=-1)</span><br><span class="line">    &#123;</span><br><span class="line">        int ret=preOrder(tree,tree[from].p1,to,depth+1);</span><br><span class="line">        if(ret!=-1)</span><br><span class="line">            return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tree[from].p2!=-1)</span><br><span class="line">    &#123;</span><br><span class="line">        int ret=preOrder(tree,tree[from].p2,to,depth+1);</span><br><span class="line">        if(ret!=-1)</span><br><span class="line">            return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    Node tree[N];//顺序存储，下标就是它所代表的字符编号，比如0代表&#x27;A&#x27;</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        if(n==0||m==0)</span><br><span class="line">            break;</span><br><span class="line">        for(int i=0;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[i].p1=tree[i].p2=-1;</span><br><span class="line">        &#125;</span><br><span class="line">        while(n--)//构建树</span><br><span class="line">        &#123;</span><br><span class="line">            char str[4];</span><br><span class="line">            cin&gt;&gt;str;</span><br><span class="line">            if(str[1]!=&#x27;-&#x27;)</span><br><span class="line">                tree[str[0]-&#x27;A&#x27;].p1=str[1]-&#x27;A&#x27;;</span><br><span class="line">            if(str[2]!=&#x27;-&#x27;)</span><br><span class="line">                tree[str[0]-&#x27;A&#x27;].p2=str[2]-&#x27;A&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        while(m--)//查询</span><br><span class="line">        &#123;</span><br><span class="line">            char str[3];</span><br><span class="line">            cin&gt;&gt;str;</span><br><span class="line">            int from=str[0]-&#x27;A&#x27;;</span><br><span class="line">            int to=str[1]-&#x27;A&#x27;;</span><br><span class="line">            int ans1=preOrder(tree,from,to,0);</span><br><span class="line">            if(ans1==1)</span><br><span class="line">                cout&lt;&lt;&quot;child&quot;&lt;&lt;endl;</span><br><span class="line">            else if(ans1&gt;=2)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int i=ans1;i&gt;2;i--)</span><br><span class="line">                    cout&lt;&lt;&quot;great-&quot;;</span><br><span class="line">                cout&lt;&lt;&quot;grandchild&quot;&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else//不是小辈，那就是长辈</span><br><span class="line">            &#123;</span><br><span class="line">                int ans2=preOrder(tree,to,from,0);</span><br><span class="line">                if(ans2==1)</span><br><span class="line">                    cout&lt;&lt;&quot;parent&quot;&lt;&lt;endl;</span><br><span class="line">                else if(ans2&gt;=2)</span><br><span class="line">                &#123;</span><br><span class="line">                    for(int i=ans2; i&gt;2; i--)</span><br><span class="line">                        cout&lt;&lt;&quot;great-&quot;;</span><br><span class="line">                    cout&lt;&lt;&quot;grandparent&quot;&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    cout&lt;&lt;&quot;-&quot;&lt;&lt;endl;//也不是长辈，那就不是直系亲属</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">吃饭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/05/%E6%A0%91%E4%B8%93%E9%A2%98%E6%95%B4%E7%90%86/">http://example.com/2022/03/05/%E6%A0%91%E4%B8%93%E9%A2%98%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">吃饭的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/%E6%A0%91.jfif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/05/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98%E6%95%B4%E7%90%86/"><img class="prev-cover" src="/./img/%E6%8E%92%E5%BA%8F.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">排序专题整理</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/04/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/"><img class="next-cover" src="/./img/c++.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++提高编程</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">吃饭</div><div class="author-info__description">吃饭比较重要</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yinbi-1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yinbi-1" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/628931484?spm_id_from=333.934.0.0" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">dy哥高考加油！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%93%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="toc-text">A. DS二叉树–二叉树构建与遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%93%E5%8F%B6%E5%AD%90%E6%95%B0%E9%87%8F"><span class="toc-text">B. DS二叉树–叶子数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E7%88%B6%E5%AD%90%E7%BB%93%E7%82%B9"><span class="toc-text">C. DS二叉树——二叉树之父子结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-DS%E6%A0%91%E2%80%93%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6"><span class="toc-text">D. DS树–二叉树高度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8"><span class="toc-text">E. DS二叉树——二叉树之数组存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%93%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BC%96%E7%A0%81%EF%BC%88%E5%90%AB%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%EF%BC%89"><span class="toc-text">F. DS二叉树–赫夫曼树的构建与编码（含代码框架）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%93%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E8%A7%A3%E7%A0%81%EF%BC%88%E5%90%AB%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6%EF%BC%89"><span class="toc-text">G. DS二叉树–赫夫曼树解码（含代码框架）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-DS%E6%A0%91%E2%80%93%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">H. DS树–带权路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%93%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-text">I. DS二叉树–基于数组存储的构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD%E2%80%93%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="toc-text">J. DS二叉树判断–同一棵二叉树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-DS%E6%A0%91%E2%80%93%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84"><span class="toc-text">K. DS树–二叉树之最大路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-DS%E6%A3%AE%E6%9E%97%E5%8F%B6%E5%AD%90%E7%BC%96%E7%A0%81"><span class="toc-text">L. DS森林叶子编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB"><span class="toc-text">M. DS二叉树—二叉树结点的最大距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E9%9D%A2%E5%8F%8D%E8%BD%AC"><span class="toc-text">DS二叉树—二叉树镜面反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-DS%E6%A0%91%E2%80%93%E6%89%BE%E5%87%BA%E7%9B%B4%E7%B3%BB%E4%BA%B2%E5%B1%9E"><span class="toc-text">O. DS树–找出直系亲属</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/" title="理解堆和栈"><img src="/./img/%E9%97%B4%E8%B0%8D%E8%BF%87%E5%AE%B6%E5%AE%B6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="理解堆和栈"/></a><div class="content"><a class="title" href="/2022/06/01/%E7%90%86%E8%A7%A3%E5%A0%86%E5%92%8C%E6%A0%88/" title="理解堆和栈">理解堆和栈</a><time datetime="2022-06-01T08:35:05.000Z" title="发表于 2022-06-01 16:35:05">2022-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/14/%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/" title="播放视频"><img src="/./img/%E5%AE%B9%E5%99%A8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="播放视频"/></a><div class="content"><a class="title" href="/2022/04/14/%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/" title="播放视频">播放视频</a><time datetime="2022-04-14T15:29:05.000Z" title="发表于 2022-04-14 23:29:05">2022-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/19/%E6%89%93%E5%8D%A1/" title="打卡记录"><img src="/./img/%E6%89%93%E5%8D%A1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="打卡记录"/></a><div class="content"><a class="title" href="/2022/03/19/%E6%89%93%E5%8D%A1/" title="打卡记录">打卡记录</a><time datetime="2022-03-19T03:06:00.000Z" title="发表于 2022-03-19 11:06:00">2022-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/16/%E5%BC%80%E6%94%BE%E5%AE%B9%E5%99%A8%E5%B9%B6%E9%85%8D%E7%BD%AE/" title="docker容器配置并配置免密登录"><img src="/./img/%E5%AE%B9%E5%99%A8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker容器配置并配置免密登录"/></a><div class="content"><a class="title" href="/2022/03/16/%E5%BC%80%E6%94%BE%E5%AE%B9%E5%99%A8%E5%B9%B6%E9%85%8D%E7%BD%AE/" title="docker容器配置并配置免密登录">docker容器配置并配置免密登录</a><time datetime="2022-03-16T03:35:05.000Z" title="发表于 2022-03-16 11:35:05">2022-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/05/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98%E6%95%B4%E7%90%86/" title="排序专题整理"><img src="/./img/%E6%8E%92%E5%BA%8F.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序专题整理"/></a><div class="content"><a class="title" href="/2022/03/05/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98%E6%95%B4%E7%90%86/" title="排序专题整理">排序专题整理</a><time datetime="2022-03-05T03:35:05.000Z" title="发表于 2022-03-05 11:35:05">2022-03-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 吃饭</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://example.com/2022/03/05/%E6%A0%91%E4%B8%93%E9%A2%98%E6%95%B4%E7%90%86/'
    this.page.identifier = '2022/03/05/树专题整理/'
    this.page.title = '树专题整理'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?yinbi-1";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="yinbi-1";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"./live2d_models/haruna/33/model.2017.valley.json"},"display":{"position":"left","width":230,"height":400},"mobile":{"show":true},"log":false});</script></body></html>